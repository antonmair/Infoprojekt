user_input
-input userinput_vector_points (the user designates 4 points, point1 & point2 describe vector1, point3 & point4 describe vector2)
 input iteration_cycles (how many times should more points be added) [stopped if no more improvements can be made!]
 {input iteration_step (how many iterated points the program starts at)}

-output{ 
  repeat following iteration_cycles amount of times

    iterated_points
      -iteration_current_cycles {+input iteration_step} 
      -output iterated_points (added points between the two staring points)

    point_positions_list
      -input userinput_vector_points + iterated_points
      -output point_positions_list (list of all current positions)

    point_angles_list (unfinished)
      -input point_positions_list 
      -point_angles_list (given list is split into a list of each point with its two nearest points) [Except the starting point of the starting vectors!]

    angle_calc_list (unfinished)
      -input point_angles_list
      -output angle_calc_list (calculate which angles have what values)

    angle_punishment (unfinished)
      -input angle_calc_list
      -output angle_punishment (positive decimal number indicating deviation of set path)
...
}


check main.py for logic and function names
functions status:
algorithm.py
 not started
angle_calc.py
 not started
angle_punishment.py
 not started
main.py
 defined logic
plotter.py
 finished
pointinserter.py
 finished



entire main and logic in pseudocode
def main
 imput of xy1-4 into polist[xy][1-4]
 for i in range (amount of lineversions)

  #non vital functions (in this segment used only for visualizationion)
  from plotter import polistplot
  polistplot()
  from angle_calc import anglecalc
  anglecalc()
  from angle_punishment import anglescript
  anglescript()

  #vital function (pointspawner and mover)
  from algorithm import heavy
  heavy()




heavy() logic (pointspawner and algorithm combined)
while (within list index)
 spawn single point according to pointspawner logic
 if point spawed
  i=i+1
 i=i+1
 #move the newly created point accoarding to the angle optimisation (in relation to points i+1 and i-1) according to anglecalc() and anglescript()
 define delta x/y from point i-1 to i+1
 while(search area < dist i+1/i-1)
  invert delta x to serch from i to search first direction
  run anglecalc() and anglescript() for rating
 while(search area < dist i+1/i-1)
  invert delta y to serch from i to search second direction
  run anglecalc() and anglescript() for rating
 set best rated as new point within polist
 

